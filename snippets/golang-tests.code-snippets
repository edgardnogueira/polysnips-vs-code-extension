{
  "Go Test Basic": {
    "prefix": "fs-go-test-basic",
    "body": [
      "func Test${1:FunctionName}(t *testing.T) {",
      "  // Arrange",
      "  ${2:input} := ${3:value}",
      "  expected := ${4:expectedValue}",
      "",
      "  // Act",
      "  result := ${5:FunctionCall}(${2:input})",
      "",
      "  // Assert",
      "  if result != expected {",
      "    t.Errorf(\"expected %v, got %v\", expected, result)",
      "  }",
      "}"
    ],
    "description": "Cria um teste básico seguindo padrão Arrange-Act-Assert"
  },

  "Go Test Table Driven": {
    "prefix": "fs-go-test-table",
    "body": [
      "func Test${1:FunctionName}(t *testing.T) {",
      "  tests := []struct {",
      "    name     string",
      "    input    ${2:type}",
      "    expected ${3:type}",
      "    wantErr  bool",
      "  }{",
      "    {",
      "      name:     \"${4:test case description}\",",
      "      input:    ${5:inputValue},",
      "      expected: ${6:expectedValue},",
      "      wantErr:  ${7:false},",
      "    },",
      "    // Adicione mais casos de teste aqui",
      "  }",
      "",
      "  for _, tt := range tests {",
      "    t.Run(tt.name, func(t *testing.T) {",
      "      result, err := ${8:FunctionCall}(tt.input)",
      "",
      "      if (err != nil) != tt.wantErr {",
      "        t.Errorf(\"expected error %v, got %v\", tt.wantErr, err)",
      "        return",
      "      }",
      "",
      "      if !tt.wantErr && result != tt.expected {",
      "        t.Errorf(\"expected %v, got %v\", tt.expected, result)",
      "      }",
      "    })",
      "  }",
      "}"
    ],
    "description": "Cria um teste table-driven com múltiplos casos de teste"
  },

  "Go Test Repository": {
    "prefix": "fs-go-test-repository",
    "body": [
      "func Test${1:Model}Repository(t *testing.T) {",
      "  // Setup do banco de teste",
      "  db, err := setupTestDB()",
      "  if err != nil {",
      "    t.Fatalf(\"failed to setup test database: %v\", err)",
      "  }",
      "",
      "  repo := New${1:Model}Repository(db)",
      "",
      "  t.Run(\"Create\", func(t *testing.T) {",
      "    ${2:model} := &${1:Model}{",
      "      ${3:Field}: ${4:value},",
      "    }",
      "",
      "    err := repo.Create(${2:model})",
      "    if err != nil {",
      "      t.Errorf(\"expected no error, got %v\", err)",
      "    }",
      "",
      "    // Verifica se foi criado",
      "    saved, err := repo.FindByID(${2:model}.ID)",
      "    if err != nil {",
      "      t.Errorf(\"expected no error, got %v\", err)",
      "    }",
      "    if saved.${3:Field} != ${2:model}.${3:Field} {",
      "      t.Errorf(\"expected %v, got %v\", ${2:model}.${3:Field}, saved.${3:Field})",
      "    }",
      "  })",
      "",
      "  t.Run(\"FindByID\", func(t *testing.T) {",
      "    // Cria registro para teste",
      "    ${2:model} := &${1:Model}{",
      "      ${3:Field}: ${4:value},",
      "    }",
      "    err := repo.Create(${2:model})",
      "    if err != nil {",
      "      t.Fatalf(\"failed to create test record: %v\", err)",
      "    }",
      "",
      "    // Busca o registro",
      "    found, err := repo.FindByID(${2:model}.ID)",
      "    if err != nil {",
      "      t.Errorf(\"expected no error, got %v\", err)",
      "    }",
      "    if found.ID != ${2:model}.ID {",
      "      t.Errorf(\"expected ID %v, got %v\", ${2:model}.ID, found.ID)",
      "    }",
      "  })",
      "",
      "  // Adicione mais casos de teste para outros métodos",
      "}"
    ],
    "description": "Cria testes para um repository do GORM"
  },

  "Go Test Service": {
    "prefix": "fs-go-test-service",
    "body": [
      "func Test${1:Model}Service(t *testing.T) {",
      "  ctrl := gomock.NewController(t)",
      "  defer ctrl.Finish()",
      "",
      "  mockRepo := mocks.NewMock${1:Model}Repository(ctrl)",
      "  service := New${1:Model}Service(mockRepo)",
      "",
      "  t.Run(\"Create Success\", func(t *testing.T) {",
      "    ctx := context.Background()",
      "    ${2:model} := &${1:Model}{",
      "      ${3:Field}: ${4:value},",
      "    }",
      "",
      "    mockRepo.EXPECT().",
      "      Create(${2:model}).",
      "      Return(nil)",
      "",
      "    err := service.Create(ctx, ${2:model})",
      "    if err != nil {",
      "      t.Errorf(\"expected no error, got %v\", err)",
      "    }",
      "  })",
      "",
      "  t.Run(\"GetByID Success\", func(t *testing.T) {",
      "    ctx := context.Background()",
      "    expected := &${1:Model}{",
      "      ID: 1,",
      "      ${3:Field}: ${4:value},",
      "    }",
      "",
      "    mockRepo.EXPECT().",
      "      FindByID(gomock.Eq(uint(1))).",
      "      Return(expected, nil)",
      "",
      "    result, err := service.GetByID(ctx, 1)",
      "    if err != nil {",
      "      t.Errorf(\"expected no error, got %v\", err)",
      "    }",
      "    if result.ID != expected.ID {",
      "      t.Errorf(\"expected ID %v, got %v\", expected.ID, result.ID)",
      "    }",
      "  })",
      "",
      "  t.Run(\"GetByID Not Found\", func(t *testing.T) {",
      "    ctx := context.Background()",
      "",
      "    mockRepo.EXPECT().",
      "      FindByID(gomock.Eq(uint(1))).",
      "      Return(nil, gorm.ErrRecordNotFound)",
      "",
      "    _, err := service.GetByID(ctx, 1)",
      "    if err == nil {",
      "      t.Error(\"expected error, got nil\")",
      "    }",
      "  })",
      "",
      "  // Adicione mais casos de teste para outros métodos",
      "}"
    ],
    "description": "Cria testes para um service usando mock do repository"
  },

  "Go Mock Setup": {
    "prefix": "fs-go-test-mock-setup",
    "body": [
      "//go:generate mockgen -source=${1:model}.go -destination=mocks/mock_${1:model}.go -package=mocks",
      "",
      "type mock${1:Model}Setup struct {",
      "  ctrl     *gomock.Controller",
      "  recorder *mocks.Mock${1:Model}Repository",
      "}",
      "",
      "func setupMock${1:Model}Test(t *testing.T) (*mock${1:Model}Setup, ${1:Model}Service) {",
      "  ctrl := gomock.NewController(t)",
      "  mockRepo := mocks.NewMock${1:Model}Repository(ctrl)",
      "  service := New${1:Model}Service(mockRepo)",
      "",
      "  return &mock${1:Model}Setup{",
      "    ctrl:     ctrl,",
      "    recorder: mockRepo,",
      "  }, service",
      "}"
    ],
    "description": "Cria setup para testes com mock"
  },

  "Go Integration Test Setup": {
    "prefix": "fs-go-test-integration-setup",
    "body": [
      "func setupIntegrationTest(t *testing.T) (*gorm.DB, func()) {",
      "  // Configuração do banco de teste",
      "  dsn := \"host=localhost user=postgres password=postgres dbname=testdb port=5432 sslmode=disable\"",
      "  db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})",
      "  if err != nil {",
      "    t.Fatalf(\"failed to connect to test database: %v\", err)",
      "  }",
      "",
      "  // Migra as tabelas",
      "  err = db.AutoMigrate(",
      "    &${1:Model}{},",
      "    // Adicione outros modelos aqui",
      "  )",
      "  if err != nil {",
      "    t.Fatalf(\"failed to migrate test database: %v\", err)",
      "  }",
      "",
      "  // Retorna função de cleanup",
      "  return db, func() {",
      "    // Limpa as tabelas após os testes",
      "    db.Exec(\"DROP TABLE IF EXISTS ${2:table_name} CASCADE\")",
      "    // Adicione outros drops aqui",
      "  }",
      "}"
    ],
    "description": "Cria setup para testes de integração com banco de dados"
  },

  "Go Benchmark Test": {
    "prefix": "fs-go-test-benchmark",
    "body": [
      "func Benchmark${1:FunctionName}(b *testing.B) {",
      "  // Setup",
      "  ${2:input} := ${3:value}",
      "",
      "  // Reset timer antes de começar o benchmark",
      "  b.ResetTimer()",
      "",
      "  // Executa o benchmark",
      "  for i := 0; i < b.N; i++ {",
      "    ${4:FunctionCall}(${2:input})",
      "  }",
      "}"
    ],
    "description": "Cria um teste de benchmark"
  },

  "Go TestMain Setup": {
    "prefix": "fs-go-test-main",
    "body": [
      "func TestMain(m *testing.M) {",
      "  // Setup global antes dos testes",
      "  ${1:// Setup code}",
      "",
      "  // Executa os testes",
      "  code := m.Run()",
      "",
      "  // Cleanup após os testes",
      "  ${2:// Cleanup code}",
      "",
      "  os.Exit(code)",
      "}"
    ],
    "description": "Cria função TestMain para setup/cleanup global dos testes"
  },

  "Go HTTP Test": {
    "prefix": "fs-go-test-http",
    "body": [
      "func Test${1:HandlerName}(t *testing.T) {",
      "  // Cria request de teste",
      "  req, err := http.NewRequest(\"${2|GET,POST,PUT,DELETE|}\", \"/${3:path}\", ${4:nil})",
      "  if err != nil {",
      "    t.Fatal(err)",
      "  }",
      "",
      "  // Cria response recorder",
      "  rr := httptest.NewRecorder()",
      "  handler := http.HandlerFunc(${1:HandlerName})",
      "",
      "  // Executa request",
      "  handler.ServeHTTP(rr, req)",
      "",
      "  // Verifica status code",
      "  if status := rr.Code; status != ${5:http.StatusOK} {",
      "    t.Errorf(\"handler returned wrong status code: got %v want %v\",",
      "      status, ${5:http.StatusOK})",
      "  }",
      "",
      "  // Verifica body da response",
      "  expected := ${6:`{\"message\":\"ok\"}`}",
      "  if rr.Body.String() != expected {",
      "    t.Errorf(\"handler returned unexpected body: got %v want %v\",",
      "      rr.Body.String(), expected)",
      "  }",
      "}"
    ],
    "description": "Cria teste para HTTP handler"
  }
}
